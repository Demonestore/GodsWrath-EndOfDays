// ArcadeCore.cs
// Single-file, 2.5D arcade-style core: movement, combat, skills & your custom Goro/God skills.
// NOTE: Uses placeholder VFX/SFX hooks so you can ship now and swap real assets later.

using System;
using System.Collections.Generic;
using UnityEngine;

namespace GodsWrath
{
    // -----------------------------
    // BOOTSTRAP & SIMPLE SINGLETONS
    // -----------------------------
    public class ArcadeGameBootstrap : MonoBehaviour
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
        static void Init()
        {
            if (FindObjectOfType<ArcadeGameBootstrap>() == null)
            {
                var go = new GameObject("ArcadeBootstrap");
                go.AddComponent<ArcadeGameBootstrap>();
                DontDestroyOnLoad(go);
            }
        }

        void Awake()
        {
            QualitySettings.vSyncCount = 0;
            Application.targetFrameRate = 60;
        }
    }

    public static class Balance
    {
        // Global tunables
        public const int MaxTargetsIceBarrage = 9;
        public const int MaxTargetsShadowBarrage = 9;
        public const int MaxTargetsTornado = 11;

        // Durations
        public const float IceBarrageFreezeSec = 15f;   // Your spec
        public const float TornadoDurSec = 5f;          // Your spec

        // Boosts (non-stacking unless stated)
        public const float IceBarrage_IceDamageBoost = 0.30f;   // +30% ice
        public const float IceBarrage_MagicBoost   = 0.15f;     // +15% magic

        public const float ShadowBarrage_MagicBoost = 0.30f;    // +30% magic
        public const float FireFromHeaven_FireBoost = 0.50f;    // 50% fire dmg (applied in effect)

        // Debuffs (examples used by skills)
        public const int ShadowBarrage_MaxPrayerDrainStacks = 3;
        public const int ShadowBarrage_MaxHealthDebuffStacks = 3;

        // God-only caps
        public const float Tornado_MagicBoost = 0.50f;          // Non-stackable, God-only
    }

    // -----------------------------
    // BASIC COMBAT MODEL
    // -----------------------------
    public enum Faction { Player, Enemy, Boss, God, Goro }
    public enum DamageSchool { Physical, Ice, Shadow, Fire, Wind, Lightning, Divine }
    public enum SkillId
    {
        None,

        // Goro-only actives
        IceBarrage,       // AOE hard-freeze, +30% ice, +15% magic, 15s
        ShadowBarrage,    // Multi-shadow projectiles, +30% magic, drains prayer, health debuff

        // God-only actives
        FireFromHeaven,   // 50% fire dmg, huge AOEr, 2 debuffs, 5s CD (your latest spec)
        Tornado,          // 5s, 11 targets, 50% magic boost (non-stackable), God controls drift
        Thunderstorm,     // God staff power (players cannot use)
        LightningStrike,  // God staff power (players cannot use)

        // Shared / placeholder slots for your future expansion
        OverhandSmash,    // Goro base attack animation style trigger
        Uppercut          // Goro MK1-style heavy knock-up (massive knockback only on uppercut)
    }

    [Serializable]
    public class StatBlock
    {
        public float MaxHP = 1000f;
        public float HP = 1000f;
        public float Attack = 50f;
        public float Defense = 20f;
        public float MoveSpeed = 4.0f;  // world units per sec
        public float AttackSpeedMult = 1.0f;

        // RPG extras
        public int Prayer = 100;
        public int MaxPrayer = 100;
        public int Rage = 0;       // 0..100 (example)
        public int MaxRage = 100;

        // Elemental multipliers (1 = normal, 1.3 = +30%)
        public float MagicMult = 1f;
        public float IceMult = 1f;
        public float FireMult = 1f;
        public float LightningMult = 1f;

        public float DamageTakenMult = 1f; // <1 reduces, >1 increases taken
    }

    public class Buff
    {
        public string Name;
        public float Duration;
        public Action<Combatant> OnApply;
        public Action<Combatant> OnExpire;
        public Action<Combatant, float> OnTick; // (owner, dt)
        public bool NonStackingKey;             // if true, reapply refreshes time instead of stacking
        float time;

        public Buff(string name, float duration, Action<Combatant> onApply = null,
            Action<Combatant> onExpire = null, Action<Combatant, float> onTick = null, bool nonStackingKey = true)
        {
            Name = name;
            Duration = duration;
            OnApply = onApply;
            OnExpire = onExpire;
            OnTick = onTick;
            NonStackingKey = nonStackingKey;
        }

        public bool Update(Combatant owner, float dt)
        {
            time += dt;
            OnTick?.Invoke(owner, dt);
            if (time >= Duration)
            {
                OnExpire?.Invoke(owner);
                return true; // finished
            }
            return false;
        }
    }

    public class Combatant : MonoBehaviour
    {
        public string DisplayName = "Unit";
        public Faction Faction = Faction.Enemy;
        public StatBlock Stats = new StatBlock();

        // Status flags
        public bool IsFrozen;
        public bool IsSleeping;

        // Buffs
        readonly List<Buff> active = new List<Buff>();

        // Simple hitbox for 2.5D
        public Vector2 Size = new Vector2(0.8f, 1.8f);

        void Update()
        {
            // Tick buffs
            for (int i = active.Count - 1; i >= 0; i--)
                if (active[i].Update(this, Time.deltaTime))
                    active.RemoveAt(i);
        }

        public void ApplyBuff(Buff b)
        {
            if (b.NonStackingKey)
            {
                // refresh same-name
                for (int i = 0; i < active.Count; i++)
                    if (active[i].Name == b.Name)
                    {
                        active[i].OnExpire?.Invoke(this);
                        active.RemoveAt(i);
                        break;
                    }
            }
            b.OnApply?.Invoke(this);
            active.Add(b);
        }

        public void DealDamage(float baseAmount, DamageSchool school, Combatant source = null)
        {
            float mult = 1f;
            switch (school)
            {
                case DamageSchool.Ice: mult *= Stats.IceMult; break;
                case DamageSchool.Fire: mult *= Stats.FireMult; break;
                default: break;
            }
            // Very light defense model (you also have def ignore on some weapons; apply before here)
            float mitigated = Mathf.Max(1f, baseAmount * mult * Stats.DamageTakenMult - Stats.Defense);
            Stats.HP -= mitigated;
            if (Stats.HP <= 0) Die();
        }

        public void HealPercent(float pct) => Stats.HP = Mathf.Min(Stats.MaxHP, Stats.HP + Stats.MaxHP * pct);

        public void Die()
        {
            // TODO: drop logic / vfx
            Destroy(gameObject);
        }

        // Utility find targets in radius (2.5D plane)
        public static List<Combatant> FindTargets(Vector3 center, float radius, Func<Combatant, bool> filter, int cap)
        {
            var all = GameObject.FindObjectsOfType<Combatant>();
            var result = new List<Combatant>();
            foreach (var c in all)
            {
                if (filter != null && !filter(c)) continue;
                if (Vector3.Distance(c.transform.position, center) <= radius)
                {
                    result.Add(c);
                    if (result.Count >= cap) break;
                }
            }
            return result;
        }
    }

    // -----------------------------
    // 2.5D ARCADE CONTROLLER (simple)
    // -----------------------------
    public class PlayerArcadeController : MonoBehaviour
    {
        public Combatant Self;
        public float Accel = 30f;
        public float Decel = 30f;

        Vector2 vel;

        void Awake()
        {
            if (!Self) Self = GetComponent<Combatant>();
        }

        void Update()
        {
            if (Self == null || Self.IsFrozen || Self.IsSleeping) return;

            // Virtual stick / keys
            float h = Input.GetAxisRaw("Horizontal");
            float v = Input.GetAxisRaw("Vertical");
            var wish = new Vector2(h, v).normalized * Self.Stats.MoveSpeed;

            // Smooth
            vel = Vector2.MoveTowards(vel, wish, (wish.magnitude > vel.magnitude ? Accel : Decel) * Time.deltaTime);
            transform.position += new Vector3(vel.x, 0, vel.y) * Time.deltaTime;

            // Face move dir
            if (vel.sqrMagnitude > 0.001f)
                transform.forward = new Vector3(vel.x, 0, vel.y);

            // Input to demo skills (map as you like)
            if (Input.GetKeyDown(KeyCode.Alpha1)) SkillRunner.TryCast(Self, SkillId.IceBarrage);
            if (Input.GetKeyDown(KeyCode.Alpha2)) SkillRunner.TryCast(Self, SkillId.ShadowBarrage);
            if (Input.GetKeyDown(KeyCode.Alpha3)) SkillRunner.TryCast(Self, SkillId.FireFromHeaven);
            if (Input.GetKeyDown(KeyCode.Alpha4)) SkillRunner.TryCast(Self, SkillId.Tornado);
            if (Input.GetKeyDown(KeyCode.Alpha5)) SkillRunner.TryCast(Self, SkillId.OverhandSmash);
            if (Input.GetKeyDown(KeyCode.Alpha6)) SkillRunner.TryCast(Self, SkillId.Uppercut);
        }
    }

    // -----------------------------
    // SKILL SYSTEM (cooldowns + effects)
    // -----------------------------
    public class SkillBook
    {
        public Dictionary<SkillId, float> Cooldowns = new();   // time remaining
        public Dictionary<SkillId, float> BaseCD = new();       // base cooldown

        public bool IsOnCD(SkillId id) => Cooldowns.TryGetValue(id, out var t) && t > 0f;

        public void SetCD(SkillId id, float sec)
        {
            if (!BaseCD.ContainsKey(id)) BaseCD[id] = sec;
            Cooldowns[id] = sec;
        }

        public void Tick(float dt)
        {
            var keys = new List<SkillId>(Cooldowns.Keys);
            foreach (var k in keys)
            {
                Cooldowns[k] = Mathf.Max(0, Cooldowns[k] - dt);
            }
        }
    }

    public class SkillRunner : MonoBehaviour
    {
        static SkillRunner _inst;
        public static SkillRunner Instance
        {
            get
            {
                if (_inst == null)
                {
                    var go = new GameObject("SkillRunner");
                    _inst = go.AddComponent<SkillRunner>();
                    DontDestroyOnLoad(go);
                }
                return _inst;
            }
        }

        class SkillHandle
        {
            public Combatant Caster;
            public SkillId Id;
            public float Elapsed;
            public float Duration;
            public Action<float> OnTick;
        }

        readonly List<SkillHandle> running = new();
        void Update()
        {
            // tick all CDs on active combatants
            foreach (var c in GameObject.FindObjectsOfType<HasSkills>())
                c.Book.Tick(Time.deltaTime);

            // tick running effects
            for (int i = running.Count - 1; i >= 0; i--)
            {
                var h = running[i];
                h.Elapsed += Time.deltaTime;
                h.OnTick?.Invoke(Time.deltaTime);
                if (h.Elapsed >= h.Duration) running.RemoveAt(i);
            }
        }

        public static bool TryCast(Combatant caster, SkillId id)
        {
            var hs = caster.GetComponent<HasSkills>();
            if (!hs) return false;

            // Player access rules
            if (!AccessRules.CanUse(caster, id)) return false;

            if (hs.Book.IsOnCD(id)) return false;

            switch (id)
            {
                // ---------- GORO ----------
                case SkillId.IceBarrage: return GoroSkills.Cast_IceBarrage(caster, hs.Book);
                case SkillId.ShadowBarrage: return GoroSkills.Cast_ShadowBarrage(caster, hs.Book);

                // ---------- GOD ----------
                case SkillId.FireFromHeaven: return GodSkills.Cast_FireFromHeaven(caster, hs.Book);
                case SkillId.Tornado: return GodSkills.Cast_Tornado(caster, hs.Book);

                // ---------- Melee anim stubs ----------
                case SkillId.OverhandSmash: return GoroSkills.Cast_OverhandSmash(caster, hs.Book);
                case SkillId.Uppercut: return GoroSkills.Cast_Uppercut(caster, hs.Book);
            }
            return false;
        }

        public static void RunTimed(Combatant caster, SkillId id, float duration, Action<float> tick = null)
        {
            var h = new SkillHandle { Caster = caster, Id = id, Duration = duration, OnTick = tick };
            Instance.running.Add(h);
        }
    }

    public class HasSkills : MonoBehaviour
    {
        public SkillBook Book = new();
    }

    // -----------------------------
    // ACCESS RULES (who may use what)
    // -----------------------------
    public static class AccessRules
    {
        public static bool CanUse(Combatant c, SkillId id)
        {
            // Player restrictions from your specs
            bool isGoro = c.Faction == Faction.Goro;
            bool isGod = c.Faction == Faction.God;

            switch (id)
            {
                case SkillId.IceBarrage:
                case SkillId.ShadowBarrage:
                    return isGoro; // Goro-only spells

                case SkillId.Tornado:
                case SkillId.Thunderstorm:
                case SkillId.LightningStrike:
                case SkillId.FireFromHeaven:
                    return isGod; // God-only skills (players can’t use Tornado/Lightning/Thunderstorm)

                default:
                    return true;
            }
        }
    }

    // -----------------------------
    // GORO SKILLS
    // -----------------------------
    public static class GoroSkills
    {
        // Ice Barrage — OSRS-inspired: hard freeze, big AOE, +30% ice & +15% magic during effect window.
        public static bool Cast_IceBarrage(Combatant c, SkillBook book)
        {
            const float radius = 5.5f; // bigger than 3x3; your request to increase radius
            const float cooldown = 5f; // you set 5s for many skills; Ice Barrage itself had no CD earlier, but we’ll keep 5s to be sane on mobile. Set to 0f if you truly want none.

            if (book.IsOnCD(SkillId.IceBarrage)) return false;

            // Apply temporary damage bonuses to the caster
            var iceBoost = new Buff("IceBarrage_IceBoost", Balance.IceBarrageFreezeSec,
                onApply: t => { t.Stats.IceMult *= (1f + Balance.IceBarrage_IceDamageBoost); t.Stats.MagicMult *= (1f + Balance.IceBarrage_MagicBoost); },
                onExpire: t => { t.Stats.IceMult /= (1f + Balance.IceBarrage_IceDamageBoost); t.Stats.MagicMult /= (1f + Balance.IceBarrage_MagicBoost); });
            c.ApplyBuff(iceBoost);

            // Find and freeze targets
            var targets = Combatant.FindTargets(c.transform.position, radius,
                t => t != c && t.Faction != c.Faction, Balance.MaxTargetsIceBarrage);

            foreach (var t in targets)
            {
                // Freeze
                t.IsFrozen = true;
                t.ApplyBuff(new Buff("Frozen", Balance.IceBarrageFreezeSec,
                    onExpire: u => u.IsFrozen = false));

                // Placeholder SFX/VFX
                VFX.PlayIceBarrage(t
